const chalk = require('chalk');
const fs = require('fs-extra');
const path = require('path');

const MARKER = '<!-- Generated by ContextKit -->';
const MARKER_END = '<!-- End ContextKit -->';
const LEGACY_MARKER = '<!-- Generated by Vibe Kit -->';
const LEGACY_MARKER_END = '<!-- End Vibe Kit -->';

class BaseIntegration {
  constructor() {
    if (new.target === BaseIntegration) {
      throw new Error('BaseIntegration is abstract and cannot be instantiated directly');
    }
    this.name = '';
    this.displayName = '';
    this.generatedFiles = [];
    this.bridgeFiles = [];
    this.platformDir = '';
  }

  async install() {
    if (this.platformDir) {
      await fs.ensureDir(this.platformDir);
    }
    await this.generateFiles();
  }

  async generateFiles() {
    throw new Error('generateFiles() must be implemented by subclass');
  }

  async validate() {
    const results = { valid: true, missing: [], present: [] };

    const allFiles = [...this.generatedFiles, ...this.bridgeFiles];
    for (const file of allFiles) {
      if (await fs.pathExists(file)) {
        results.present.push(file);
      } else {
        results.missing.push(file);
        results.valid = false;
      }
    }

    return results;
  }

  async writeBridgeFile(filePath, content) {
    const dir = path.dirname(filePath);
    if (dir !== '.') {
      await fs.ensureDir(dir);
    }

    const markedContent = `${MARKER}\n${content}\n${MARKER_END}`;

    if (await fs.pathExists(filePath)) {
      const existing = await fs.readFile(filePath, 'utf-8');

      // Check for current or legacy markers
      const hasCurrentMarker = existing.includes(MARKER);
      const hasLegacyMarker = existing.includes(LEGACY_MARKER);

      if (hasCurrentMarker || hasLegacyMarker) {
        const activeMarker = hasCurrentMarker ? MARKER : LEGACY_MARKER;
        const activeMarkerEnd = hasCurrentMarker ? MARKER_END : LEGACY_MARKER_END;
        const before = existing.substring(0, existing.indexOf(activeMarker));
        const afterMarkerEnd = existing.indexOf(activeMarkerEnd);
        const after = afterMarkerEnd !== -1
          ? existing.substring(afterMarkerEnd + activeMarkerEnd.length)
          : '';
        await fs.writeFile(filePath, before + markedContent + after);
      } else {
        // Append below existing content
        await fs.writeFile(filePath, existing.trimEnd() + '\n\n' + markedContent + '\n');
      }
    } else {
      await fs.writeFile(filePath, markedContent + '\n');
    }
  }

  async writeGeneratedFile(filePath, content) {
    const dir = path.dirname(filePath);
    if (dir !== '.') {
      await fs.ensureDir(dir);
    }
    await fs.writeFile(filePath, content);
  }

  getStandardsBlock() {
    return `## Project Standards

The following standards files define this project's conventions:

- \`.contextkit/standards/code-style.md\` — Coding conventions and style rules
- \`.contextkit/standards/testing.md\` — Testing patterns and requirements
- \`.contextkit/standards/architecture.md\` — Architecture decisions and patterns
- \`.contextkit/standards/ai-guidelines.md\` — AI behavior and usage guidelines
- \`.contextkit/standards/workflows.md\` — Development workflows and processes
- \`.contextkit/standards/glossary.md\` — Project terminology and shortcuts

## Product Context

- \`.contextkit/product/mission-lite.md\` — Product mission (condensed)
- \`.contextkit/product/decisions.md\` — Architecture Decision Records
- \`.contextkit/product/roadmap.md\` — Development roadmap

## Commands

- \`.contextkit/commands/analyze.md\` — Analyze and customize standards
- \`.contextkit/commands/create-component.md\` — Create components
- \`.contextkit/commands/create-feature.md\` — Create features
- \`.contextkit/commands/run-tests.md\` — Run tests
- \`.contextkit/commands/quality-check.md\` — Quality checks`;
  }

  showUsage() {
    console.log('');
    console.log(chalk.dim(`  See .contextkit/standards/ for project standards`));
  }
}

module.exports = BaseIntegration;
