const chalk = require('chalk');
const fs = require('fs-extra');
const path = require('path');
const yaml = require('js-yaml');

class CheckCommand {
  constructor() {
    this.errors = [];
    this.warnings = [];
    this.info = [];
  }

  async run(options = {}) {
    console.log(chalk.magenta('üîç ContextKit Validation Check\n'));

    if (!await fs.pathExists('.contextkit/config.yml')) {
      console.log(chalk.red('‚ùå ContextKit not installed'));
      console.log(chalk.yellow('   Run: contextkit install'));
      return;
    }

    // Load config
    const config = await this.loadConfig();
    if (!config) {
      return;
    }

    // Run checks
    await this.checkManifest(config);
    await this.checkRequiredFiles(config);
    await this.checkOptionalFiles(config);
    await this.checkStandardsFreshness(config);
    await this.checkPolicyCompliance(config);
    await this.checkPlatformIntegrations();

    // Display results
    this.displayResults(options);

    // Exit with appropriate code
    if (this.errors.length > 0) {
      process.exit(1);
    } else if (this.warnings.length > 0 && options.strict) {
      process.exit(1);
    }
  }

  async loadConfig() {
    try {
      const configContent = await fs.readFile('.contextkit/config.yml', 'utf-8');
      return yaml.load(configContent);
    } catch (error) {
      this.errors.push('Failed to load config.yml: ' + error.message);
      return null;
    }
  }

  async checkManifest(config) {
    // Check manifest schema
    if (!config.ck) {
      this.warnings.push('Manifest missing "ck" field (should be 1)');
    }

    if (!config.version) {
      this.warnings.push('Manifest missing "version" field');
    }

    if (!config.updated) {
      this.warnings.push('Manifest missing "updated" field');
    }

    if (!config.profile) {
      this.warnings.push('Manifest missing "profile" field');
    }

    if (config.metadata) {
      this.info.push(`Generated by: ${config.metadata.generated_by || 'unknown'}`);
      if (config.metadata.generated_at) {
        this.info.push(`Generated at: ${config.metadata.generated_at}`);
      }
    }
  }

  async checkRequiredFiles(config) {
    if (!config.required || !Array.isArray(config.required)) {
      this.warnings.push('No required files specified in config');
      return;
    }

    for (const file of config.required) {
      const filePath = `.contextkit/${file}`;
      if (!await fs.pathExists(filePath)) {
        this.errors.push(`Required file missing: ${file}`);
      } else {
        this.info.push(`‚úì Required file exists: ${file}`);
      }
    }
  }

  async checkOptionalFiles(config) {
    if (!config.optional || !Array.isArray(config.optional)) {
      return;
    }

    for (const file of config.optional) {
      const filePath = `.contextkit/${file}`;
      if (!await fs.pathExists(filePath)) {
        this.warnings.push(`Optional file missing: ${file}`);
      }
    }
  }

  async checkStandardsFreshness(config) {
    // Load policy to get freshness threshold
    let freshnessDays = 90; // default
    try {
      if (await fs.pathExists('.contextkit/policies/policy.yml')) {
        const policyContent = await fs.readFile('.contextkit/policies/policy.yml', 'utf-8');
        const policy = yaml.load(policyContent);
        if (policy?.enforcement?.standards?.freshness_days) {
          freshnessDays = policy.enforcement.standards.freshness_days;
        }
      }
    } catch (error) {
      // Policy file might not exist or be invalid, use default
    }

    // Check standards files
    const standardsFiles = [
      'standards/code-style.md',
      'standards/testing.md',
      'standards/architecture.md',
      'standards/ai-guidelines.md',
      'standards/workflows.md'
    ];

    for (const file of standardsFiles) {
      const filePath = `.contextkit/${file}`;
      if (await fs.pathExists(filePath)) {
        const stats = await fs.stat(filePath);
        const daysSinceUpdate = (Date.now() - stats.mtime.getTime()) / (1000 * 60 * 60 * 24);
        
        if (daysSinceUpdate > freshnessDays) {
          this.warnings.push(
            `Standards file outdated: ${file} (last updated ${Math.floor(daysSinceUpdate)} days ago, threshold: ${freshnessDays} days)`
          );
        }
      }
    }
  }

  async checkPolicyCompliance(config) {
    try {
      if (!await fs.pathExists('.contextkit/policies/policy.yml')) {
        this.warnings.push('Policy file missing: policies/policy.yml');
        return;
      }

      const policyContent = await fs.readFile('.contextkit/policies/policy.yml', 'utf-8');
      const policy = yaml.load(policyContent);

      if (!policy.enforcement) {
        this.warnings.push('Policy file missing enforcement rules');
        return;
      }

      // Check testing policy
      if (policy.enforcement.testing) {
        if (policy.enforcement.testing.numbered_cases === 'block') {
          // Check if testing.md mentions numbered test cases
          const testingPath = '.contextkit/standards/testing.md';
          if (await fs.pathExists(testingPath)) {
            const content = await fs.readFile(testingPath, 'utf-8');
            if (!content.includes('numbered') && !content.includes('1., 2., 3.')) {
              this.errors.push('Testing standards must require numbered test cases (policy: block)');
            }
          }
        }
      }

      this.info.push('‚úì Policy file exists and is valid');
    } catch (error) {
      this.warnings.push(`Policy check failed: ${error.message}`);
    }
  }

  async checkPlatformIntegrations() {
    const fs = require('fs-extra');

    // Check for deprecated files and suggest modern alternatives
    const deprecations = [
      {
        file: '.cursor/rules/contextkit.mdc',
        message: 'Deprecated monolithic Cursor rule found. Run: ck cursor (creates scoped rules)',
      },
      {
        file: '.codex/README.md',
        bridge: 'AGENTS.md',
        message: 'Legacy .codex/README.md found without AGENTS.md. Run: ck codex',
      },
      {
        file: '.gemini/README.md',
        bridge: 'GEMINI.md',
        message: 'Legacy .gemini/README.md found without GEMINI.md. Run: ck gemini',
      },
      {
        file: '.claude/README.md',
        bridge: 'CLAUDE.md',
        message: 'Legacy .claude/README.md found without CLAUDE.md. Run: ck claude',
      },
    ];

    for (const dep of deprecations) {
      if (await fs.pathExists(dep.file)) {
        if (dep.bridge) {
          if (!await fs.pathExists(dep.bridge)) {
            this.warnings.push(dep.message);
          }
        } else {
          this.warnings.push(dep.message);
        }
      }
    }

    // Check bridge file presence for common platforms
    const bridgeChecks = [
      { file: 'CLAUDE.md', platform: 'claude', label: 'Claude Code' },
      { file: 'AGENTS.md', platform: 'codex', label: 'Codex CLI' },
      { file: 'GEMINI.md', platform: 'gemini', label: 'Gemini CLI' },
      { file: 'CONVENTIONS.md', platform: 'aider', label: 'Aider' },
      { file: '.windsurfrules', platform: 'windsurf', label: 'Windsurf' },
      { file: '.github/copilot-instructions.md', platform: 'copilot', label: 'GitHub Copilot' },
    ];

    let anyBridge = false;
    for (const check of bridgeChecks) {
      if (await fs.pathExists(check.file)) {
        this.info.push(`‚úì ${check.label} bridge file: ${check.file}`);
        anyBridge = true;
      }
    }

    if (!anyBridge) {
      this.warnings.push('No platform bridge files found. Run: ck <platform> (e.g., ck claude, ck cursor)');
    }
  }

  displayResults(options) {
    console.log('‚îÄ'.repeat(60));

    if (this.errors.length > 0) {
      console.log(chalk.red(`\n‚ùå Errors (${this.errors.length}):`));
      this.errors.forEach(error => {
        console.log(chalk.red(`  ‚Ä¢ ${error}`));
      });
    }

    if (this.warnings.length > 0) {
      console.log(chalk.yellow(`\n‚ö†Ô∏è  Warnings (${this.warnings.length}):`));
      this.warnings.forEach(warning => {
        console.log(chalk.yellow(`  ‚Ä¢ ${warning}`));
      });
    }

    if (this.info.length > 0 && options.verbose) {
      console.log(chalk.blue(`\n‚ÑπÔ∏è  Info (${this.info.length}):`));
      this.info.forEach(info => {
        console.log(chalk.blue(`  ‚Ä¢ ${info}`));
      });
    }

    console.log('\n' + '‚îÄ'.repeat(60));

    // Summary
    if (this.errors.length === 0 && this.warnings.length === 0) {
      console.log(chalk.green('\n‚úÖ All checks passed!'));
    } else if (this.errors.length === 0) {
      console.log(chalk.yellow(`\n‚ö†Ô∏è  ${this.warnings.length} warning(s) found (use --strict to fail on warnings)`));
    } else {
      console.log(chalk.red(`\n‚ùå ${this.errors.length} error(s) found`));
    }
  }
}

async function check(options) {
  const cmd = new CheckCommand();
  await cmd.run(options);
}

module.exports = check;

